package com.trivago.kangaroo.long2long;

import com.trivago.kangaroo.AbstractCommonBenchHelper;
import org.openjdk.jmh.annotations.Level;
import org.openjdk.jmh.annotations.Measurement;
import org.openjdk.jmh.annotations.Scope;
import org.openjdk.jmh.annotations.Setup;
import org.openjdk.jmh.annotations.State;
import org.openjdk.jmh.annotations.Warmup;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ThreadLocalRandom;

@State(Scope.Benchmark)
@Warmup(iterations = 3, time = 1)
@Measurement(iterations = 3, time = 2)
public class JavaConcurrentLongLongBenchmark extends AbstractCommonBenchHelper {

    Map<Long, Long> map;

    /**
     * Initializes the concurrent map with random key-value pairs for the benchmarking trial.
     *
     * <p>This setup method, annotated with {@code @Setup(Level.Trial)}, creates a {@link java.util.concurrent.ConcurrentHashMap}
     * using a predefined capacity and load factor, then populates it with entries where both keys and values are random long
     * values generated by {@link java.util.concurrent.ThreadLocalRandom}.
     */
    @Setup(Level.Trial)
    public void loadData() {
        map = new ConcurrentHashMap<>(AbstractLongLongBenchHelper.NUM_VALUES, 0.8f);
        for (int i = 0; i < AbstractLongLongBenchHelper.NUM_VALUES; i++) {
            long key = ThreadLocalRandom.current().nextLong();
            long value = ThreadLocalRandom.current().nextLong();
            map.put(key, value);
        }
    }

    /**
     * Benchmarks a get operation on the concurrent map by retrieving a value using a randomly generated key.
     *
     * <p>This method generates a random long key with ThreadLocalRandom and performs a lookup in the map,
     * serving as part of the benchmarking process for concurrent retrieval performance.
     */
    @Override
		public void testGet() {
        long key = ThreadLocalRandom.current().nextLong();
        map.get(key);
    }

    /**
     * Inserts a random key-value pair into the map.
     *
     * <p>This method generates random long values for both the key and the value using ThreadLocalRandom,
     * and inserts the generated pair into the map. It overrides the superclass method to simulate a put
     * operation within a concurrent benchmarking environment.
     */
    @Override
		public void testPut() {
        long key = ThreadLocalRandom.current().nextLong();
        long value = ThreadLocalRandom.current().nextLong();
        map.put(key, value);
    }

    /**
     * Executes a randomly selected operation on the concurrent map.
     *
     * <p>This method simulates mixed access patterns by performing one of three operations:
     * <ul>
     *   <li>A put operation, inserting a new entry with random long key and value.</li>
     *   <li>A remove operation, deleting an entry corresponding to a random long key.</li>
     *   <li>A get operation, retrieving the value for a random long key.</li>
     * </ul>
     *
     * <p>These operations are used for concurrent benchmarking of map performance.
     */
    @Override
		public void testAllOps() {
        int op = ThreadLocalRandom.current().nextInt(3);
        long key = ThreadLocalRandom.current().nextLong();
        switch (op) {
            case 1:
                long value = ThreadLocalRandom.current().nextLong();
                map.put(key, value);
                break;
            case 2:
                map.remove(key);
                break;
            default:
                map.get(key);
                break;
        }
    }
}